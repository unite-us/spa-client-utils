"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _choices = _interopRequireDefault(require("@unite-us/choices.js"));

var _lodash = _interopRequireDefault(require("lodash"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var SelectField = /*#__PURE__*/function (_PureComponent) {
  _inherits(SelectField, _PureComponent);

  var _super = _createSuper(SelectField);

  function SelectField(props) {
    var _this;

    _classCallCheck(this, SelectField);

    _this = _super.call(this, props);
    _this.asyncCallback = _this.asyncCallback.bind(_assertThisInitialized(_this));
    _this.debounceSetIsOpen = _lodash["default"].debounce(_this.setIsOpen, 200);
    _this.handleToggle = _this.handleToggle.bind(_assertThisInitialized(_this));
    _this.onChange = _this.onChange.bind(_assertThisInitialized(_this));
    _this.onHideDropdown = _this.onHideDropdown.bind(_assertThisInitialized(_this));
    _this.onSearch = _this.onSearch.bind(_assertThisInitialized(_this));
    _this.onShowDropdown = _this.onShowDropdown.bind(_assertThisInitialized(_this));
    _this.setIsOpen = _this.setIsOpen.bind(_assertThisInitialized(_this));
    _this.setOptions = _this.setOptions.bind(_assertThisInitialized(_this));
    _this.setValue = _this.setValue.bind(_assertThisInitialized(_this));
    _this.shouldAutoSelect = _this.shouldAutoSelect.bind(_assertThisInitialized(_this));
    _this.toggleDisabled = _this.toggleDisabled.bind(_assertThisInitialized(_this));
    _this.updateSearchPlaceholderValue = _this.updateSearchPlaceholderValue.bind(_assertThisInitialized(_this));
    _this.updateChoicesValue = _this.updateChoicesValue.bind(_assertThisInitialized(_this));
    _this.state = {
      asyncOptions: [],
      isOpen: false
    };
    return _this;
  }

  _createClass(SelectField, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props = this.props,
          clearable = _this$props.clearable,
          disabled = _this$props.disabled,
          loadingText = _this$props.loadingText,
          loadOnMount = _this$props.loadOnMount,
          loadOptions = _this$props.loadOptions,
          options = _this$props.options,
          placeholder = _this$props.placeholder,
          position = _this$props.position,
          renderChoiceLimit = _this$props.renderChoiceLimit,
          resetScrollPosition = _this$props.resetScrollPosition,
          searchChoices = _this$props.searchChoices,
          searchEnabled = _this$props.searchEnabled,
          searchPlaceholderValue = _this$props.searchPlaceholderValue,
          searchResultLimit = _this$props.searchResultLimit,
          shouldSort = _this$props.shouldSort;
      this.choices = new _choices["default"](this.element, {
        itemSelectText: '',
        loadingText: loadingText,
        placeholderValue: placeholder,
        position: position,
        removeItemButton: clearable,
        renderChoiceLimit: renderChoiceLimit,
        resetScrollPosition: resetScrollPosition,
        searchChoices: searchChoices,
        searchEnabled: searchEnabled,
        searchFields: ['label'],
        searchPlaceholderValue: searchPlaceholderValue,
        searchResultLimit: searchResultLimit,
        shouldSort: shouldSort,
        silent: true
      });
      this.setOptions({
        options: options,
        placeholder: placeholder
      });
      this.toggleDisabled(disabled);
      this.element.addEventListener('change', this.onChange);
      this.element.addEventListener('search', this.onSearch);
      this.element.addEventListener('showDropdown', this.onShowDropdown);
      this.element.addEventListener('hideDropdown', this.onHideDropdown);

      if (loadOnMount && loadOptions) {
        this.onSearch({
          detail: {
            value: ''
          }
        });
      }
    }
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      if (this.props.placeholder !== nextProps.placeholder) {
        this.setOptions({
          options: nextProps.options,
          placeholder: nextProps.placeholder
        });
      }

      if (this.props.searchPlaceholderValue !== nextProps.searchPlaceholderValue) {
        this.updateSearchPlaceholderValue(nextProps.searchPlaceholderValue);
      }

      if (this.props.disabled !== nextProps.disabled) {
        this.toggleDisabled(nextProps.disabled);
      }

      if (!_lodash["default"].isEqual(this.props.options, nextProps.options)) {
        this.setOptions({
          options: nextProps.options,
          placeholder: nextProps.placeholder
        });
      }

      if (!_lodash["default"].isEqual((0, _utils.getPreferredProp)(this.props, 'value'), (0, _utils.getPreferredProp)(nextProps, 'value'))) {
        this.setValue((0, _utils.getPreferredProp)(nextProps, 'value'));
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.element) {
        this.element.removeEventListener('change', this.onChange);
        this.element.removeEventListener('search', this.onSearch);
        this.element.removeEventListener('showDropdown', this.onShowDropdown);
        this.element.removeEventListener('hideDropdown', this.onHideDropdown);
      }

      this.choices.destroy();
    }
  }, {
    key: "onChange",
    value: function onChange() {
      var _this$props2 = this.props,
          valueKey = _this$props2.valueKey,
          options = _this$props2.options,
          forceObjectValue = _this$props2.forceObjectValue,
          shouldSearchOnChange = _this$props2.shouldSearchOnChange;
      var rawValue = this.choices.getValue();
      var optionList = _lodash["default"].isEmpty(options) ? this.state.asyncOptions : options;
      var value = (0, _utils.getSelectValue)(rawValue, valueKey, optionList, forceObjectValue);

      if (shouldSearchOnChange) {
        this.onSearch();
      }

      var callback = (0, _utils.getPreferredProp)(this.props, 'onChange');

      if (_lodash["default"].isFunction(callback)) {
        callback(value);
      }

      if (_lodash["default"].isFunction(this.props.onChange) && !_lodash["default"].isEqual(this.props.onChange, (0, _utils.getPreferredProp)(this.props, 'onChange'))) {
        this.props.onChange(value);
      }
    }
  }, {
    key: "onSearch",
    value: function onSearch(event) {
      var _this2 = this;

      var _this$props3 = this.props,
          loadOptions = _this$props3.loadOptions,
          placeholder = _this$props3.placeholder;

      if (_lodash["default"].isFunction(loadOptions)) {
        var search = _lodash["default"].get(event, 'detail.value', '');

        var result = loadOptions(search, this.asyncCallback());

        if (result instanceof Promise) {
          result.then(function (response) {
            var options = _lodash["default"].get(response, 'options', []);

            _this2.setOptions({
              options: options,
              placeholder: placeholder
            });

            _this2.setState({
              asyncOptions: options
            });
          });
        }
      }
    }
  }, {
    key: "onShowDropdown",
    value: function onShowDropdown(event) {
      var reduxFormOnFocus = (0, _utils.getPreferredProp)(this.props, 'onFocus');

      var manualPropsOnFocus = _lodash["default"].get(this.props, 'onFocus');

      if (_lodash["default"].isFunction(reduxFormOnFocus)) {
        reduxFormOnFocus(event);
      }

      if (_lodash["default"].isFunction(manualPropsOnFocus) && reduxFormOnFocus !== manualPropsOnFocus) {
        manualPropsOnFocus(event);
      }

      this.debounceSetIsOpen(true);
    }
  }, {
    key: "onHideDropdown",
    value: function onHideDropdown() {
      var _this$props4 = this.props,
          valueKey = _this$props4.valueKey,
          options = _this$props4.options,
          forceObjectValue = _this$props4.forceObjectValue,
          shouldSearchOnHide = _this$props4.shouldSearchOnHide;
      var rawValue = this.choices.getValue();
      var optionList = _lodash["default"].isEmpty(this.state.asyncOptions) ? options : this.state.asyncOptions;
      var value = (0, _utils.getSelectValue)(rawValue, valueKey, optionList, forceObjectValue);
      var onBlur = (0, _utils.getPreferredProp)(this.props, 'onBlur');
      this.debounceSetIsOpen(false);
      this.choices.clearInput();

      if (shouldSearchOnHide) {
        this.onSearch();
      }

      if (_lodash["default"].isFunction(onBlur)) {
        onBlur(value);
      } // adding clearTimeout closes dropdown w/o it the dropdown reopens in Internet Explorer.


      clearTimeout(this.debounceSetIsOpen(false));
    }
    /**
     * Sets the selected value(s)
     * @param {(string|object)} value
     * @public
     */

  }, {
    key: "setValue",
    value: function setValue(originalValue) {
      var _this$props5 = this.props,
          multiple = _this$props5.multiple,
          options = _this$props5.options;
      var value = originalValue;

      if (this.shouldAutoSelect()) {
        if (multiple) {
          value = [options[0]];
        } else {
          value = options[0];
        }
      }

      this.updateChoicesValue(value);

      if (this.shouldAutoSelect()) {
        this.onChange();
      }
    }
    /**
     * Sets the list of options
     * @param { array } options - Options on the dropdown
     * @param { boolean } replace - default to true, passed to choices.js.  clear option and reset them.
     & @param { string } placeholder - placeholder text in the SelectField
     * @public
     */

  }, {
    key: "setOptions",
    value: function setOptions(_ref) {
      var options = _ref.options,
          _ref$replace = _ref.replace,
          replace = _ref$replace === void 0 ? true : _ref$replace,
          placeholder = _ref.placeholder;
      var _this$props6 = this.props,
          labelKey = _this$props6.labelKey,
          multiple = _this$props6.multiple,
          valueKey = _this$props6.valueKey;
      var choices = (0, _utils.buildChoices)(options, valueKey, labelKey, multiple, placeholder);
      this.choices.setChoices(choices, 'value', 'label', replace);
      this.setValue((0, _utils.getPreferredProp)(this.props, 'value'));
    }
  }, {
    key: "setIsOpen",
    value: function setIsOpen(isOpen) {
      this.setState({
        isOpen: isOpen
      });
    }
  }, {
    key: "updateSearchPlaceholderValue",
    value: function updateSearchPlaceholderValue(newSearchPlaceholderProp) {
      this.choices.config.searchPlaceholderValue = newSearchPlaceholderProp;
      this.choices.input.placeholder = newSearchPlaceholderProp;
    }
  }, {
    key: "asyncCallback",
    value: function asyncCallback() {
      var _this3 = this;

      return function (response) {
        var options = _lodash["default"].get(response, 'options', []);

        _this3.setOptions({
          options: options
        });

        _this3.setState({
          asyncOptions: options
        });
      };
    }
  }, {
    key: "shouldAutoSelect",
    value: function shouldAutoSelect() {
      var _this$props7 = this.props,
          autoSelectValue = _this$props7.autoSelectValue,
          required = _this$props7.required,
          options = _this$props7.options;
      return autoSelectValue && required && options.length === 1;
    }
  }, {
    key: "updateChoicesValue",
    value: function updateChoicesValue(value) {
      var _this$props8 = this.props,
          multiple = _this$props8.multiple,
          placeholder = _this$props8.placeholder,
          valueKey = _this$props8.valueKey;

      if (_lodash["default"].isEmpty(value)) {
        this.choices.removeActiveItems();

        if (!multiple && !_lodash["default"].isEmpty(placeholder)) {
          this.choices.setValueByChoice('');
        }

        return this.choices;
      }

      if (_lodash["default"].isString(value)) {
        return this.choices.setValueByChoice(value);
      }

      if (_lodash["default"].isArray(value)) {
        this.choices.removeActiveItems();
        return this.choices.setValueByChoice(_lodash["default"].map(value, function (val) {
          return _lodash["default"].get(val, valueKey, val);
        }));
      }

      return this.choices.setValueByChoice(_lodash["default"].get(value, valueKey, ''));
    }
    /**
     * Should the component be disabled or enabled
     * @param {boolean} disabled
     * @public
     */

  }, {
    key: "toggleDisabled",
    value: function toggleDisabled(disabled) {
      if (disabled) {
        this.choices.disable();
      } else {
        this.choices.enable();
      }
    }
  }, {
    key: "handleToggle",
    value: function handleToggle(e) {
      e.nativeEvent.stopImmediatePropagation();

      if (!this.state.isOpen) {
        this.debounceSetIsOpen(true);
        this.choices.showDropdown();
        this.choices.input.focus();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var _this$props9 = this.props,
          className = _this$props9.className,
          dataTestElement = _this$props9.dataTestElement,
          disabled = _this$props9.disabled,
          hideError = _this$props9.hideError,
          hideHint = _this$props9.hideHint,
          hideLabel = _this$props9.hideLabel,
          hint = _this$props9.hint,
          id = _this$props9.id,
          inline = _this$props9.inline,
          label = _this$props9.label,
          labelClassName = _this$props9.labelClassName,
          labelKey = _this$props9.labelKey,
          multiple = _this$props9.multiple,
          options = _this$props9.options,
          postLabelContent = _this$props9.postLabelContent,
          required = _this$props9.required,
          style = _this$props9.style;
      var hasError = (0, _utils.getPreferredProp)(this.props, 'invalid') && (0, _utils.getPreferredProp)(this.props, 'touched');

      var containerClass = function containerClass() {
        return (0, _classnames["default"])({
          'ui-select-field': true,
          'ui-form-field': true,
          'ui-form-field--inline': inline,
          'ui-form-field--has-error': hasError,
          'ui-form-field--disabled': disabled,
          'ui-select-field--has-error': hasError
        }, className);
      };

      var labelClass = function labelClass() {
        return (0, _classnames["default"])(_defineProperty({
          'ui-form-field__label': true,
          'ui-form-field__label--required': required,
          'sr-only': hideLabel
        }, labelClassName, !_lodash["default"].isEmpty(labelClassName)));
      };

      var selectClass = function selectClass() {
        return (0, _classnames["default"])({
          hidden: _this4.shouldAutoSelect()
        });
      };

      return /*#__PURE__*/_react["default"].createElement("div", {
        className: containerClass(),
        style: style.container
      }, /*#__PURE__*/_react["default"].createElement("label", {
        htmlFor: id,
        className: labelClass(),
        style: style.label
      }, label), postLabelContent, /*#__PURE__*/_react["default"].createElement("div", {
        style: {
          position: 'relative'
        }
      }, /*#__PURE__*/_react["default"].createElement("div", {
        className: selectClass(),
        "data-test-element": dataTestElement || "dropdown_".concat((0, _utils.getPreferredProp)(this.props, 'name'))
      }, /*#__PURE__*/_react["default"].createElement("select", {
        id: id,
        multiple: multiple,
        name: (0, _utils.getPreferredProp)(this.props, 'name'),
        onBlur: (0, _utils.getPreferredProp)(this.props, 'onBlur'),
        onFocus: (0, _utils.getPreferredProp)(this.props, 'onFocus'),
        ref: function ref(c) {
          _this4.element = c;
        }
      })), multiple && /*#__PURE__*/_react["default"].createElement("button", {
        "aria-label": "Select multiple ",
        className: (0, _classnames["default"])({
          'multiple-selector': true,
          open: this.state.isOpen
        }),
        onClick: this.handleToggle,
        type: "button",
        tabIndex: 0
      }), this.shouldAutoSelect() && /*#__PURE__*/_react["default"].createElement("div", {
        className: "ui-select-field__auto-selected"
      }, _lodash["default"].get(options, "[0].".concat(labelKey))), !hideHint && /*#__PURE__*/_react["default"].createElement("div", {
        className: "ui-form-field__hint",
        style: style.hint
      }, hint), !hideError && /*#__PURE__*/_react["default"].createElement("div", {
        className: "ui-form-field__error",
        style: style.error
      }, (0, _utils.getPreferredProp)(this.props, 'error'))));
    }
  }]);

  return SelectField;
}(_react.PureComponent);

SelectField.propTypes = _objectSpread({
  /** Should the value be auto-selected when only one option available? */
  autoSelectValue: _propTypes["default"].bool,

  /** className for reference */
  className: _propTypes["default"].string,

  /** Show clear item button */
  clearable: _propTypes["default"].bool,

  /** dataTestElement for qa testing */
  dataTestElement: _propTypes["default"].string,

  /** Is the select disabled? */
  disabled: _propTypes["default"].bool,

  /** should the value be the object rather than the value string? */
  forceObjectValue: _propTypes["default"].bool,

  /** Should the label be hidden? */
  hideLabel: _propTypes["default"].bool,

  /** Remove Hint element */
  hideHint: _propTypes["default"].bool,

  /** Remove Error element */
  hideError: _propTypes["default"].bool,

  /** Help text displayed below the select */
  hint: _propTypes["default"].node,

  /** id for reference */
  id: _propTypes["default"].string.isRequired,

  /** Should the label be displayed inline with the select? */
  inline: _propTypes["default"].bool,

  /** label text for button */
  label: _propTypes["default"].node.isRequired,

  /** Key used for the label */
  labelKey: _propTypes["default"].string,

  /**
   * Asynchronous options load function returning a Promise
   * @param {string} input - The search term
   */
  loadOptions: _propTypes["default"].func,

  /** Calls loadOptions with an empty string on mount if true */
  loadOnMount: _propTypes["default"].bool,

  /** The text that is shown while searching, defaults to empty string */
  loadingText: _propTypes["default"].string,

  /** Is multiple select? */
  multiple: _propTypes["default"].bool,

  /** Select options */
  options: _propTypes["default"].array,

  /** Placeholder text */
  placeholder: _propTypes["default"].string,

  /** Where the dropdown should appear in relation to the input */
  position: _propTypes["default"].oneOf(['auto', 'top', 'bottom']),

  /** Content block that is placed between the label and the field */
  postLabelContent: _propTypes["default"].node,

  /** How many options should be rendered? */
  renderChoiceLimit: _propTypes["default"].number,

  /** Is the field required */
  required: _propTypes["default"].bool,

  /** Whether scroll position should reset after adding an item?, defaults to true */
  resetScrollPosition: _propTypes["default"].bool,

  /** False to disable Choices native search, defaults to true. */
  searchChoices: _propTypes["default"].bool,

  /** If true, search is enabled */
  searchEnabled: _propTypes["default"].bool,

  /** Placeholder for free text input */
  searchPlaceholderValue: _propTypes["default"].string,

  /** Number of results to display */
  searchResultLimit: _propTypes["default"].number,

  /** Should the options be automaticaly sorted? */
  shouldSort: _propTypes["default"].bool,

  /** if true, search is triggered when selection is changed  */
  shouldSearchOnChange: _propTypes["default"].bool,

  /** if true, search is triggered when hiding the drop down  */
  shouldSearchOnHide: _propTypes["default"].bool,

  /** Override the inline-styles of the elements || **Not Recommended** */
  style: _propTypes["default"].shape({
    container: _propTypes["default"].object,
    label: _propTypes["default"].object,
    input: _propTypes["default"].object,
    hint: _propTypes["default"].object,
    error: _propTypes["default"].object
  }),

  /** Key used for the label */
  valueKey: _propTypes["default"].string
}, _utils.fieldProps);
SelectField.defaultProps = {
  autoSelectValue: false,
  className: '',
  clearable: true,
  dataTestElement: '',
  disabled: false,
  inline: false,
  forceObjectValue: false,
  hideHint: false,
  hideError: false,
  hideLabel: false,
  hint: '',
  labelClassName: '',
  labelKey: 'label',
  loadingText: '',
  loadOnMount: false,
  loadOptions: null,
  multiple: false,
  options: [],
  placeholder: '',
  position: 'bottom',
  postLabelContent: null,
  renderChoiceLimit: -1,
  required: false,
  resetScrollPosition: false,
  searchChoices: true,
  searchEnabled: true,
  searchPlaceholderValue: '',
  searchResultLimit: 10,
  shouldSort: true,
  shouldSearchOnChange: true,
  shouldSearchOnHide: true,
  style: {
    container: {},
    error: {},
    hint: {},
    label: {}
  },
  valueKey: 'value'
};
var _default = SelectField;
exports["default"] = _default;